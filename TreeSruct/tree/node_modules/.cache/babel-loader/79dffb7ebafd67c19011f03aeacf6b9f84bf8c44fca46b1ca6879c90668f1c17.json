{"ast":null,"code":"var _jsxFileName = \"C:\\\\OSPanel\\\\domains\\\\Project1-master\\\\TreeSruct\\\\tree\\\\src\\\\FileStructure\\\\helpers.js\";\nimport { ReactComponent as IconFolderClosed } from './img/folder-closed.svg';\nimport { ReactComponent as IconFolderOpened } from './img/folder-opened.svg';\nimport { ReactComponent as IconArrowClosed } from './img/arrow-closed.svg';\nimport { ReactComponent as IconArrowOpened } from './img/arrow-opened.svg';\nimport { ReactComponent as IconCameraEnabled } from './img/camera-enabled.svg';\nimport { ReactComponent as IconCameraDisabled } from './img/camera-disabled.svg';\nimport { ReactComponent as IconEventsGroup } from './img/events-group.svg';\nimport { ReactComponent as IconRealtime } from './img/realtime.svg';\n\n//\n// Get icon by type\n//\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const getIcon = type => {\n  switch (type) {\n    case 'folder':\n      return /*#__PURE__*/_jsxDEV(IconFolderClosed, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 17,\n        columnNumber: 27\n      }, this);\n    case 'folder_opened':\n      return /*#__PURE__*/_jsxDEV(IconFolderOpened, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 18,\n        columnNumber: 34\n      }, this);\n    case 'arrow_closed':\n      return /*#__PURE__*/_jsxDEV(IconArrowClosed, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 19,\n        columnNumber: 33\n      }, this);\n    case 'arrow_opened':\n      return /*#__PURE__*/_jsxDEV(IconArrowOpened, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 20,\n        columnNumber: 33\n      }, this);\n    case 'camera':\n      return /*#__PURE__*/_jsxDEV(IconCameraDisabled, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 21,\n        columnNumber: 27\n      }, this);\n    case 'camera_enabled':\n      return /*#__PURE__*/_jsxDEV(IconCameraEnabled, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 22,\n        columnNumber: 35\n      }, this);\n    case 'events_group':\n      return /*#__PURE__*/_jsxDEV(IconEventsGroup, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 23,\n        columnNumber: 33\n      }, this);\n    case 'realtime':\n      return /*#__PURE__*/_jsxDEV(IconRealtime, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 24,\n        columnNumber: 29\n      }, this);\n    default:\n      return null;\n  }\n};\n\n//\n// Convert raw JSON response to unique IDs used for UI\n//\n\nconst generatedArray = [];\nconst generateUniqueId = () => {\n  const random = Math.ceil(Math.random() * (99999 - 10000) + 10000);\n  if (!generatedArray.includes(random)) {\n    generatedArray.push(random);\n    return random;\n  } else {\n    return generateUniqueId();\n  }\n};\n\n//\n// Transform raw JSON from backend to add uniqueIds needed for frontend\n//\n\nexport const transformRawJSONToAddUniqueIds = tree => {\n  if (!tree) return [];\n  return tree.map(node => {\n    const newNode = {\n      ...node,\n      uniqueId: generateUniqueId()\n    };\n    if (node.contains) {\n      newNode.contains = transformRawJSONToAddUniqueIds(node.contains);\n    }\n    return newNode;\n  });\n};\n\n//\n// Rename node in tree by it's uniquId\n//\n\nexport const renameNodeInTreeByUniqueId = (tree, uniqueId, newName) => tree.map(node => {\n  if (node.uniqueId === uniqueId) {\n    return {\n      ...node,\n      name: newName\n    };\n  } else if (node.contains) {\n    return {\n      ...node,\n      contains: renameNodeInTreeByUniqueId(node.contains, uniqueId, newName)\n    };\n  } else {\n    return node;\n  }\n});\n\n//\n// Find node in tree by given uniqueId and remove from original tree\n// Returns array with [ removedNode, and originalTreeWithoutRemovedNode ]\n//\n\nconst findNodeByUniqueIdAndRemoveFromTree = (tree, targetUniqueId) => {\n  let removedNode;\n  let treeWithoutRemovedNode;\n  const walkOnTree = (tree, targetUniqueId) => {\n    // Firstly, filter current level of tree to remove target and save it for return\n    const filteredTree = tree.filter(node => {\n      if (node.uniqueId === targetUniqueId) {\n        removedNode = node;\n        return false;\n      }\n      return true;\n    });\n\n    // Map our countains props for every object in given tree and return it\n    return filteredTree.map(node => {\n      const {\n        contains,\n        ...nodeWithoutContains\n      } = node;\n      const returnObj = {\n        ...nodeWithoutContains,\n        contains: []\n      };\n      if (contains) {\n        returnObj.contains = walkOnTree(contains, targetUniqueId);\n      }\n      return returnObj;\n    });\n  };\n  treeWithoutRemovedNode = walkOnTree(tree, targetUniqueId);\n  return [removedNode, treeWithoutRemovedNode];\n};\n\n//\n// Insert given node into node with given uniqueId\n//\n\nconst insertGivenNodeIntoNodeWithGivenUniqueId = (tree, nodeToInsert, whereToInsertUniqueId) => {\n  const walkOnTree = (tree, nodeToInsert, whereToInsertUniqueId) => {\n    return tree.map(node => {\n      const {\n        contains,\n        ...nodeWithoutContains\n      } = node;\n      const newNodeState = {\n        ...nodeWithoutContains\n      };\n      if (node.type === 'folder' || node.type === 'camera') {\n        newNodeState.contains = [];\n      }\n      if (node.uniqueId === whereToInsertUniqueId) {\n        newNodeState.contains = [...contains, nodeToInsert];\n      } else if (contains && contains.length) {\n        newNodeState.contains = walkOnTree(contains, nodeToInsert, whereToInsertUniqueId);\n      }\n      return newNodeState;\n    });\n  };\n  return walkOnTree(tree, nodeToInsert, whereToInsertUniqueId);\n};\n\n//\n// Move node with given uniqueId to other node\n//\n\nexport const moveNode = (tree, whatToMoveUniqueId, whereToMoveUniqueId) => {\n  const [nodeWithGivenUniqueId, treeWithoutNodeWithGivenUniqueId] = findNodeByUniqueIdAndRemoveFromTree(tree, whatToMoveUniqueId);\n  return insertGivenNodeIntoNodeWithGivenUniqueId(treeWithoutNodeWithGivenUniqueId, nodeWithGivenUniqueId, whereToMoveUniqueId);\n};\n\n//\n// Sort tree alphabetically, folders at the top\n//\n\nexport const sortTree = tree => {\n  const walkOnTree = tree => {\n    return tree.map(node => {\n      const {\n        contains,\n        ...nodeWithoutContains\n      } = node;\n      const newNodeState = {\n        ...nodeWithoutContains\n      };\n      if (node.type === 'folder' || node.type === 'camera') {\n        newNodeState.contains = [];\n      }\n      if (contains && contains.length) {\n        const sortFunc = (a, b) => {\n          if (a.name < b.name) return -1;\n          if (a.name > b.name) return 1;\n          return 0;\n        };\n        const onlyFolders = contains.filter(node => node.type === 'folder').sort(sortFunc);\n        const restNodes = contains.filter(node => node.type !== 'folder').sort(sortFunc);\n        newNodeState.contains = walkOnTree([...onlyFolders, ...restNodes]);\n      }\n      return newNodeState;\n    });\n  };\n  return walkOnTree(tree);\n};","map":{"version":3,"names":["ReactComponent","IconFolderClosed","IconFolderOpened","IconArrowClosed","IconArrowOpened","IconCameraEnabled","IconCameraDisabled","IconEventsGroup","IconRealtime","jsxDEV","_jsxDEV","getIcon","type","fileName","_jsxFileName","lineNumber","columnNumber","generatedArray","generateUniqueId","random","Math","ceil","includes","push","transformRawJSONToAddUniqueIds","tree","map","node","newNode","uniqueId","contains","renameNodeInTreeByUniqueId","newName","name","findNodeByUniqueIdAndRemoveFromTree","targetUniqueId","removedNode","treeWithoutRemovedNode","walkOnTree","filteredTree","filter","nodeWithoutContains","returnObj","insertGivenNodeIntoNodeWithGivenUniqueId","nodeToInsert","whereToInsertUniqueId","newNodeState","length","moveNode","whatToMoveUniqueId","whereToMoveUniqueId","nodeWithGivenUniqueId","treeWithoutNodeWithGivenUniqueId","sortTree","sortFunc","a","b","onlyFolders","sort","restNodes"],"sources":["C:/OSPanel/domains/Project1-master/TreeSruct/tree/src/FileStructure/helpers.js"],"sourcesContent":["import { ReactComponent as IconFolderClosed } from './img/folder-closed.svg'\r\nimport { ReactComponent as IconFolderOpened } from './img/folder-opened.svg'\r\nimport { ReactComponent as IconArrowClosed } from './img/arrow-closed.svg'\r\nimport { ReactComponent as IconArrowOpened } from './img/arrow-opened.svg'\r\nimport { ReactComponent as IconCameraEnabled } from './img/camera-enabled.svg'\r\nimport { ReactComponent as IconCameraDisabled } from './img/camera-disabled.svg'\r\nimport { ReactComponent as IconEventsGroup } from './img/events-group.svg'\r\nimport { ReactComponent as IconRealtime } from './img/realtime.svg'\r\n\r\n\r\n//\r\n// Get icon by type\r\n//\r\n\r\nexport const getIcon = (type) => {\r\n  switch (type) {\r\n    case 'folder': return <IconFolderClosed />\r\n    case 'folder_opened': return <IconFolderOpened />\r\n    case 'arrow_closed': return <IconArrowClosed />\r\n    case 'arrow_opened': return <IconArrowOpened />\r\n    case 'camera': return <IconCameraDisabled />\r\n    case 'camera_enabled': return <IconCameraEnabled />\r\n    case 'events_group': return <IconEventsGroup />\r\n    case 'realtime': return <IconRealtime />\r\n    default: return null\r\n  }\r\n}\r\n\r\n\r\n//\r\n// Convert raw JSON response to unique IDs used for UI\r\n//\r\n\r\nconst generatedArray = []\r\n\r\nconst generateUniqueId = () => {\r\n  const random = Math.ceil(Math.random() * (99999 - 10000) + 10000)\r\n\r\n  if (!generatedArray.includes(random)) {\r\n    generatedArray.push(random)\r\n    return random\r\n  } else {\r\n    return generateUniqueId()\r\n  }\r\n}\r\n\r\n\r\n//\r\n// Transform raw JSON from backend to add uniqueIds needed for frontend\r\n//\r\n\r\nexport const transformRawJSONToAddUniqueIds = (tree) => {\r\n  if (!tree) return []\r\n\r\n  return tree.map((node) => {\r\n    const newNode = {\r\n      ...node,\r\n      uniqueId: generateUniqueId(),\r\n    }\r\n\r\n    if (node.contains) {\r\n      newNode.contains = transformRawJSONToAddUniqueIds(node.contains)\r\n    }\r\n\r\n    return newNode\r\n  })\r\n}\r\n\r\n\r\n//\r\n// Rename node in tree by it's uniquId\r\n//\r\n\r\nexport const renameNodeInTreeByUniqueId = (tree, uniqueId, newName) => (\r\n  tree.map((node) => {\r\n    if (node.uniqueId === uniqueId) {\r\n      return {\r\n        ...node,\r\n        name: newName,\r\n      }\r\n    } else if (node.contains) {\r\n      return {\r\n        ...node,\r\n        contains: renameNodeInTreeByUniqueId(node.contains, uniqueId, newName)\r\n      }\r\n    } else {\r\n      return node\r\n    }\r\n  })\r\n)\r\n\r\n\r\n//\r\n// Find node in tree by given uniqueId and remove from original tree\r\n// Returns array with [ removedNode, and originalTreeWithoutRemovedNode ]\r\n//\r\n\r\nconst findNodeByUniqueIdAndRemoveFromTree = (tree, targetUniqueId) => {\r\n  let removedNode\r\n  let treeWithoutRemovedNode\r\n\r\n  const walkOnTree = (tree, targetUniqueId) => {\r\n    // Firstly, filter current level of tree to remove target and save it for return\r\n    const filteredTree = tree.filter((node) => {\r\n      if (node.uniqueId === targetUniqueId) {\r\n        removedNode = node\r\n        return false\r\n      }\r\n\r\n      return true\r\n    })\r\n\r\n    // Map our countains props for every object in given tree and return it\r\n    return filteredTree.map((node) => {\r\n      const { contains, ...nodeWithoutContains } = node\r\n\r\n      const returnObj = { ...nodeWithoutContains, contains: [] }\r\n\r\n      if (contains) {\r\n        returnObj.contains = walkOnTree(contains, targetUniqueId)\r\n      }\r\n\r\n      return returnObj\r\n    })\r\n  }\r\n\r\n  treeWithoutRemovedNode = walkOnTree(tree, targetUniqueId)\r\n\r\n  return [ removedNode, treeWithoutRemovedNode ]\r\n}\r\n\r\n\r\n//\r\n// Insert given node into node with given uniqueId\r\n//\r\n\r\nconst insertGivenNodeIntoNodeWithGivenUniqueId = (tree, nodeToInsert, whereToInsertUniqueId) => {\r\n  const walkOnTree = (tree, nodeToInsert, whereToInsertUniqueId) => {\r\n    return tree.map((node) => {\r\n      const { contains, ...nodeWithoutContains } = node\r\n\r\n      const newNodeState = { ...nodeWithoutContains }\r\n\r\n      if (node.type === 'folder' || node.type === 'camera') {\r\n        newNodeState.contains = []\r\n      }\r\n\r\n      if (node.uniqueId === whereToInsertUniqueId) {\r\n        newNodeState.contains = [\r\n          ...contains,\r\n          nodeToInsert,\r\n        ]\r\n      } else if (contains && contains.length) {\r\n        newNodeState.contains = walkOnTree(contains, nodeToInsert, whereToInsertUniqueId)\r\n      }\r\n\r\n      return newNodeState\r\n    })\r\n  }\r\n\r\n  return walkOnTree(tree, nodeToInsert, whereToInsertUniqueId)\r\n}\r\n\r\n\r\n//\r\n// Move node with given uniqueId to other node\r\n//\r\n\r\nexport const moveNode = (tree, whatToMoveUniqueId, whereToMoveUniqueId) => {\r\n  const [\r\n    nodeWithGivenUniqueId,\r\n    treeWithoutNodeWithGivenUniqueId\r\n  ] = findNodeByUniqueIdAndRemoveFromTree(tree, whatToMoveUniqueId)\r\n\r\n  return insertGivenNodeIntoNodeWithGivenUniqueId(\r\n    treeWithoutNodeWithGivenUniqueId,\r\n    nodeWithGivenUniqueId,\r\n    whereToMoveUniqueId\r\n  )\r\n}\r\n\r\n\r\n//\r\n// Sort tree alphabetically, folders at the top\r\n//\r\n\r\nexport const sortTree = (tree) => {\r\n  const walkOnTree = (tree) => {\r\n    return tree.map((node) => {\r\n      const { contains, ...nodeWithoutContains } = node\r\n\r\n      const newNodeState = { ...nodeWithoutContains }\r\n\r\n      if (node.type === 'folder' || node.type === 'camera') {\r\n        newNodeState.contains = []\r\n      }\r\n\r\n      if (contains && contains.length) {\r\n        const sortFunc = (a, b) => {\r\n          if (a.name < b.name) return -1\r\n          if (a.name > b.name) return 1\r\n          return 0\r\n        }\r\n\r\n        const onlyFolders = contains.filter((node) => node.type === 'folder').sort(sortFunc)\r\n        const restNodes = contains.filter((node) => node.type !== 'folder').sort(sortFunc)\r\n\r\n        newNodeState.contains = walkOnTree([\r\n          ...onlyFolders,\r\n          ...restNodes,\r\n        ])\r\n      }\r\n\r\n      return newNodeState\r\n    })\r\n  }\r\n\r\n  return walkOnTree(tree)\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}